# Getting Started

## Step 1: Customer Input

- **Action:** Provide the basic information required for the testing process, including the correct URLs of the application (frontend/backend), necessary credentials, and any specific testing requirements. This input enables TestSprite's AI to understand the testing scope and tailor a customized plan for your needs. We don’t rely on templates—every result is generated by our AI's intelligence through real-time analysis.

## Step 2: Test Plans Auto Generation
- TestSprite’s AI creates a detailed testing plan customized to your needs. This plan includes a thoughtfully crafted list of test cases, each targeting a specific scenario related to the case you might want to test or should be covered for your product. Every test case comes with a clear description that explains its purpose and the rationale for the testing process.


> Example test plan for back-end API testing:
> when testing the [Amazon S3 `create_bucket` API](https://boto3.amazonaws.com/v1/documentation/api/latest/reference/services/s3/client/create_bucket.html), integration test cases should cover various scenarios to ensure that the bucket creation process works correctly. Here is a generated testing plan to review:
> 1. **Basic Bucket Creation:**
> - Test creating a new S3 bucket with a unique name. Verify that the bucket exists after creation.
> 2. **Bucket Name Validation:**
> - Test creating a bucket with an invalid name (e.g., containing special characters, spaces, or exceeding character limits). Verify that the API returns an appropriate error response.
> 3. **Bucket Location Constraint:**
> - Test creating a bucket with a specific location constraint (e.g., us-east-1, eu-west-1). Verify that the bucket is created in the specified region.
> 4. **Access Control List (ACL) Testing:**
> - Test creating a bucket with different ACL settings (e.g., private, public-read, authenticated-read). Verify that the ACL settings are applied correctly to the bucket.
> 5. **Bucket Versioning:**
> - Test creating a bucket with versioning enabled. Verify that versioning is correctly enabled for the bucket.
> 6. **...**

## Step 3: User Review & Confirmation
- **Action:** Before proceeding, users can review the automatically generated test plans. This step allows you to adjust, add, or remove specific tests and ensure the generated plans align with your testing goals.

## Step 4: Test Code Auto Generation (Implementation)
- Once confirmed, TestSprite’s AI automatically generates the testing code based on the user-approved test plan and uploads it to our cloud service for compilation, ensuring it is ready for execution. Our AI resolves any compilation issues and applies self-patching if adjustments are needed, delivering the highest accuracy among all Testing Autopilot tools.

```python filename="Example AI generated test code: s3_bucket_testing.py" copy
import unittest
import boto3
from botocore.exceptions import ClientError

class TestCreateBucketAPI(unittest.TestCase):
    @classmethod
    def setUpClass(cls):
        # Initialize the S3 client
        cls.s3_client = boto3.client('s3')

    def test_basic_bucket_creation(self):
        bucket_name = 'test-bucket-basic'

        try:
            # Test creating a new S3 bucket
            self.s3_client.create_bucket(Bucket=bucket_name)
        except ClientError as e:
            self.fail(f"Error creating basic bucket: {e}")

        # Verify that the bucket exists
        response = self.s3_client.list_buckets()
        buckets = [bucket['Name'] for bucket in response['Buckets']]
        self.assertIn(bucket_name, buckets)

    def test_invalid_bucket_name(self):
        invalid_bucket_names = ['bucket with spaces', 'bucket_with_special_characters!']

        for bucket_name in invalid_bucket_names:
            with self.subTest(bucket_name=bucket_name):
                with self.assertRaises(ClientError) as context:
                    # Test creating a bucket with an invalid name
                    self.s3_client.create_bucket(Bucket=bucket_name)

                self.assertEqual(context.exception.response['Error']['Code'], 'InvalidBucketName')

    # And the other test cases ...

if __name__ == '__main__':
    unittest.main()
```
## Step 5: Test Execution
- TestSprite automatically executes the generated test cases in our cloud environment, closely monitoring the results to promptly detect any issues.

## Step 6: Review and Adjust
- **Action:** After the tests are executed, you can review the results and make any necessary adjustments directly in the console using our online VS Code plugin or by providing suggestions in natural language. At this stage, our AI analyzes any test failures and even searches online for information to help identify the potential root cause and suggest the most likely fix.

## Step 7: Final Testing Report
- **Action:** TestSprite will generates a detailed report of the testing process, highlighting the results of each test case, areas for improvement, and any errors or vulnerabilities detected. This report can be shared with your team for further action or kept as a record for future reference.
